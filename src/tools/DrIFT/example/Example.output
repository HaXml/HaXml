{-% DrIFT (Automatic class derivations for Haskell) v1.0 %-}
./Foo.lhs
{- example script for derive -}

module Example where
import Foo

{-! global : has,is !-} -- global to this module
{-!for Data derive : update,Show,Read!-} -- stand alone comand syntax 
{-!for Foo derive : test, Show,Read !-} -- apply rules to imported type
{-!for Maybe derive : test !-} -- apply rules to prelude type

data Data = D {	name :: Name,		
			constraints :: [(Class,Var)], 
			vars :: [Var],	
			body :: [(Constructor,[(Name,Type)])],
			derive :: [Class],
			statement :: Statement}
	   | FnType {	name :: Name,
			constraints :: [(Class,Var)],
			fntype :: Type}
	   | Fn	{	name :: Name,
			vars :: [Var]}	
	   | Directive
		 {-!derive : test!-} -- abbreviated syntax
{-!for Statement derive : Eq,Ord,Enum,Show,Read,Bounded !-}
{-!for Type derive : Eq,Ord,Enum,Bounded,Read !-}
data Statement = DataStmt | NewTypeStmt
type Name = String
type Var = String
type Class = String
type Constructor = String

data Type	= Arrow Type Type -- fn
		| Apply Type Type -- application
		| Var String	  -- variable
		| Con String      -- constructor / type e.g. Int, Char
		| Tuple [Type]	  -- tuple
		| List Type	  -- list
			 deriving Show

data (Eq a) => G a b = F (a->b) b | H a a {-!derive: test !-}
newtype Q = Q Int {-!derive:test!-}

{-* Generated by DrIFT-v1.0 : Look, but Don't Touch. *-}
{-Data
  Body "D" ["name","constraints","vars","body","derive","statement"] [Con "Name",List (Tuple [Con "Class",Con "Var"]),List (Con "Var"),List (Tuple [Con "Constructor",List (Tuple [Con "Name",Con "Type"])]),List (Con "Class"),Con "Statement"]
  Body "FnType" ["name","constraints","fntype"] [Con "Name",List (Tuple [Con "Class",Con "Var"]),Con "Type"]
  Body "Fn" ["name","vars"] [Con "Name",List (Con "Var")]
  Body "Directive" [] []
  DataStmt-}

hasname D{} = True
hasname FnType{} = True
hasname Fn{} = True
hasname Directive{} = False
hasconstraints D{} = True
hasconstraints FnType{} = True
hasconstraints Fn{} = False
hasconstraints Directive{} = False
hasvars D{} = True
hasvars FnType{} = False
hasvars Fn{} = True
hasvars Directive{} = False
hasbody D{} = True
hasbody FnType{} = False
hasbody Fn{} = False
hasbody Directive{} = False
hasderive D{} = True
hasderive FnType{} = False
hasderive Fn{} = False
hasderive Directive{} = False
hasstatement D{} = True
hasstatement FnType{} = False
hasstatement Fn{} = False
hasstatement Directive{} = False
hasfntype D{} = False
hasfntype FnType{} = True
hasfntype Fn{} = False
hasfntype Directive{} = False

isD (D aa ab ac ad ae af) = True
isD _ = False
isFnType (FnType aa ab ac) = True
isFnType _ = False
isFn (Fn aa ab) = True
isFn _ = False
isDirective (Directive) = True
isDirective _ = False

-- Warning - can't derive `has' functions for non-record type: Statement

isDataStmt (DataStmt) = True
isDataStmt _ = False
isNewTypeStmt (NewTypeStmt) = True
isNewTypeStmt _ = False

-- Warning - can't derive `has' functions for non-record type: Type

isArrow (Arrow aa ab) = True
isArrow _ = False
isApply (Apply aa ab) = True
isApply _ = False
isVar (Var aa) = True
isVar _ = False
isCon (Con aa) = True
isCon _ = False
isTuple (Tuple aa) = True
isTuple _ = False
isList (List aa) = True
isList _ = False

{-G
  ("Eq", "a")
  "a" "b"
  Body "F" [] [Arrow (Var "a") (Var "b"),Var "b"]
  Body "H" [] [Var "a",Var "a"]
  DataStmt-}

-- Warning - can't derive `has' functions for non-record type: G

isF (F aa ab) = True
isF _ = False
isH (H aa ab) = True
isH _ = False

{-Q
  Body "Q" [] [Con "Int"]
  NewTypeStmt-}

-- Warning - can't derive `has' functions for non-record type: Q

isQ (Q aa) = True
isQ _ = False

instance Eq Type where
    (Arrow aa ab) == (Arrow aa' ab') = aa == aa' && ab == ab'
    (Apply aa ab) == (Apply aa' ab') = aa == aa' && ab == ab'
    (Var aa) == (Var aa') = aa == aa'
    (Con aa) == (Con aa') = aa == aa'
    (Tuple aa) == (Tuple aa') = aa == aa'
    (List aa) == (List aa') = aa == aa'
    _ == _ = False

instance Ord Type where
    compare (Arrow aa ab) (Arrow aa' ab') =
	    foldl (\x y -> if x == EQ then compare y EQ else y) EQ
	    [compare aa aa',compare ab ab']
    compare (Arrow aa ab) (Apply aa' ab') = LT
    compare (Arrow aa ab) (Var aa') = LT
    compare (Arrow aa ab) (Con aa') = LT
    compare (Arrow aa ab) (Tuple aa') = LT
    compare (Arrow aa ab) (List aa') = LT
    compare (Apply aa ab) (Arrow aa' ab') = GT
    compare (Apply aa ab) (Apply aa' ab') =
	    foldl (\x y -> if x == EQ then compare y EQ else y) EQ
	    [compare aa aa',compare ab ab']
    compare (Apply aa ab) (Var aa') = LT
    compare (Apply aa ab) (Con aa') = LT
    compare (Apply aa ab) (Tuple aa') = LT
    compare (Apply aa ab) (List aa') = LT
    compare (Var aa) (Arrow aa' ab') = GT
    compare (Var aa) (Apply aa' ab') = GT
    compare (Var aa) (Var aa') = compare aa aa'
    compare (Var aa) (Con aa') = LT
    compare (Var aa) (Tuple aa') = LT
    compare (Var aa) (List aa') = LT
    compare (Con aa) (Arrow aa' ab') = GT
    compare (Con aa) (Apply aa' ab') = GT
    compare (Con aa) (Var aa') = GT
    compare (Con aa) (Con aa') = compare aa aa'
    compare (Con aa) (Tuple aa') = LT
    compare (Con aa) (List aa') = LT
    compare (Tuple aa) (Arrow aa' ab') = GT
    compare (Tuple aa) (Apply aa' ab') = GT
    compare (Tuple aa) (Var aa') = GT
    compare (Tuple aa) (Con aa') = GT
    compare (Tuple aa) (Tuple aa') = compare aa aa'
    compare (Tuple aa) (List aa') = LT
    compare (List aa) (Arrow aa' ab') = GT
    compare (List aa) (Apply aa' ab') = GT
    compare (List aa) (Var aa') = GT
    compare (List aa) (Con aa') = GT
    compare (List aa) (Tuple aa') = GT
    compare (List aa) (List aa') = compare aa aa'

-- Warning -- can't derive Enum for Type

-- Warning -- can't derive Bounded for Type

instance Read Type where
    readsPrec d input =
	      readParen (d > 9)
	      (\ inp ->
	       [((Arrow aa ab) , rest) | ("Arrow" , inp) <- lex inp ,
		(aa , inp) <- readsPrec 10 inp , (ab , rest) <- readsPrec 10 inp])
	      input
	      ++
	      readParen (d > 9)
	      (\ inp ->
	       [((Apply aa ab) , rest) | ("Apply" , inp) <- lex inp ,
		(aa , inp) <- readsPrec 10 inp , (ab , rest) <- readsPrec 10 inp])
	      input
	      ++
	      readParen (d > 9)
	      (\ inp ->
	       [((Var aa) , rest) | ("Var" , inp) <- lex inp ,
		(aa , rest) <- readsPrec 10 inp])
	      input
	      ++
	      readParen (d > 9)
	      (\ inp ->
	       [((Con aa) , rest) | ("Con" , inp) <- lex inp ,
		(aa , rest) <- readsPrec 10 inp])
	      input
	      ++
	      readParen (d > 9)
	      (\ inp ->
	       [((Tuple aa) , rest) | ("Tuple" , inp) <- lex inp ,
		(aa , rest) <- readsPrec 10 inp])
	      input
	      ++
	      readParen (d > 9)
	      (\ inp ->
	       [((List aa) , rest) | ("List" , inp) <- lex inp ,
		(aa , rest) <- readsPrec 10 inp])
	      input

instance Eq Statement where
    DataStmt == DataStmt = True
    NewTypeStmt == NewTypeStmt = True
    _ == _ = False

instance Ord Statement where
    compare DataStmt (DataStmt) = EQ
    compare DataStmt (NewTypeStmt) = LT
    compare NewTypeStmt (DataStmt) = GT
    compare NewTypeStmt (NewTypeStmt) = EQ

instance Enum Statement where
    fromEnum DataStmt = 0
    fromEnum NewTypeStmt = 1
    toEnum 0 = DataStmt
    toEnum 1 = NewTypeStmt
    enumFrom e = drop (fromEnum e) [DataStmt,NewTypeStmt]
    enumFromThen i j = enumFromThen' i j ( enumFrom i )
	where
	enumFromThen' _ _ [] = []
	enumFromThen' i j (x:xs) = let d = fromEnum j - fromEnum i in x :
		      enumFromThen' i j ( drop (d-1) xs )

instance Show Statement where
    showsPrec d (DataStmt) = showString "DataStmt"
    showsPrec d (NewTypeStmt) = showString "NewTypeStmt"

instance Read Statement where
    readsPrec d input =
	      (\ inp -> [((DataStmt) , rest) | ("DataStmt" , rest) <- lex inp])
	      input
	      ++
	      (\ inp ->
	       [((NewTypeStmt) , rest) | ("NewTypeStmt" , rest) <- lex inp])
	      input

instance Bounded Statement where
    minBound = DataStmt
    maxBound = NewTypeStmt

{-Maybe
  "a"
  Body "Just" [] [Var "a"] Body "Nothing" [] []
  "Eq" "Ord" "Read" "Show"
  DataStmt-}

body_u f r@D{body} = r{body = f body}
constraints_u f r@D{constraints} = r{constraints = f constraints}
constraints_u f r@FnType{constraints} = r{constraints = f constraints}
derive_u f r@D{derive} = r{derive = f derive}
fntype_u f r@FnType{fntype} = r{fntype = f fntype}
name_u f r@D{name} = r{name = f name}
name_u f r@Fn{name} = r{name = f name}
name_u f r@FnType{name} = r{name = f name}
statement_u f r@D{statement} = r{statement = f statement}
vars_u f r@D{vars} = r{vars = f vars}
vars_u f r@Fn{vars} = r{vars = f vars}
body_s v =  body_u  (const v)
constraints_s v =  constraints_u  (const v)
derive_s v =  derive_u  (const v)
fntype_s v =  fntype_u  (const v)
name_s v =  name_u  (const v)
statement_s v =  statement_u  (const v)
vars_s v =  vars_u  (const v)

instance Show Data where
    showsPrec d (D aa ab ac ad ae af) = showParen (d >= 10)
	      (showString "D" . showChar '{' .
	       showString "name" . showChar '=' . showsPrec 10 aa . showChar ',' .
	       showString "constraints" . showChar '=' . showsPrec 10 ab
	       . showChar ',' . showString "vars" . showChar '=' . showsPrec 10 ac
	       . showChar ',' . showString "body" . showChar '=' . showsPrec 10 ad
	       . showChar ',' .
	       showString "derive" . showChar '=' . showsPrec 10 ae
	       . showChar ',' .
	       showString "statement" . showChar '=' . showsPrec 10 af
	       . showChar '}')
    showsPrec d (FnType aa ab ac) = showParen (d >= 10)
	      (showString "FnType" . showChar '{' .
	       showString "name" . showChar '=' . showsPrec 10 aa . showChar ',' .
	       showString "constraints" . showChar '=' . showsPrec 10 ab
	       . showChar ',' .
	       showString "fntype" . showChar '=' . showsPrec 10 ac
	       . showChar '}')
    showsPrec d (Fn aa ab) = showParen (d >= 10)
	      (showString "Fn" . showChar '{' .
	       showString "name" . showChar '=' . showsPrec 10 aa . showChar ',' .
	       showString "vars" . showChar '=' . showsPrec 10 ab
	       . showChar '}')
    showsPrec d (Directive) = showString "Directive"

instance Read Data where
    readsPrec d input =
	      readParen (d > 9)
	      (\ inp ->
	       [((D aa ab ac ad ae af) , rest) | ("D" , inp) <- lex inp ,
		("{" , inp) <- lex inp , ("name" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (aa , inp) <- readsPrec 10 inp ,
		("," , inp) <- lex inp , ("constraints" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (ab , inp) <- readsPrec 10 inp ,
		("," , inp) <- lex inp , ("vars" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (ac , inp) <- readsPrec 10 inp ,
		("," , inp) <- lex inp , ("body" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (ad , inp) <- readsPrec 10 inp ,
		("," , inp) <- lex inp , ("derive" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (ae , inp) <- readsPrec 10 inp ,
		("," , inp) <- lex inp , ("statement" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (af , inp) <- readsPrec 10 inp ,
		("}" , rest) <- lex inp])
	      input
	      ++
	      readParen (d > 9)
	      (\ inp ->
	       [((FnType aa ab ac) , rest) | ("FnType" , inp) <- lex inp ,
		("{" , inp) <- lex inp , ("name" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (aa , inp) <- readsPrec 10 inp ,
		("," , inp) <- lex inp , ("constraints" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (ab , inp) <- readsPrec 10 inp ,
		("," , inp) <- lex inp , ("fntype" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (ac , inp) <- readsPrec 10 inp ,
		("}" , rest) <- lex inp])
	      input
	      ++
	      readParen (d > 9)
	      (\ inp ->
	       [((Fn aa ab) , rest) | ("Fn" , inp) <- lex inp ,
		("{" , inp) <- lex inp , ("name" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (aa , inp) <- readsPrec 10 inp ,
		("," , inp) <- lex inp , ("vars" , inp) <- lex inp ,
		("=" , inp) <- lex inp , (ab , inp) <- readsPrec 10 inp ,
		("}" , rest) <- lex inp])
	      input
	      ++
	      (\ inp -> [((Directive) , rest) | ("Directive" , rest) <- lex inp])
	      input

--  Imported from other files :-

{-Foo
  Body "Foo" [] [] Body "Bar" [] [] Body "Bub" [] []
  DataStmt-}

instance Show Foo where
    showsPrec d (Foo) = showString "Foo"
    showsPrec d (Bar) = showString "Bar"
    showsPrec d (Bub) = showString "Bub"

instance Read Foo where
    readsPrec d input =
	      (\ inp -> [((Foo) , rest) | ("Foo" , rest) <- lex inp]) input
	      ++
	      (\ inp -> [((Bar) , rest) | ("Bar" , rest) <- lex inp]) input
	      ++
	      (\ inp -> [((Bub) , rest) | ("Bub" , rest) <- lex inp]) input

