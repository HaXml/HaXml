module Text.ParserCombinators.TextParser
  ( -- * The Parse class is a replacement for the Read class.  It is a
    --   specialisation of the (poly) Parser monad for String input.
    TextParser	-- synonym for Parser () Char, i.e. string input, no state
  , Parse(..)	-- instances: (), (a,b), (a,b,c), Maybe a, Either a, [a],
		--            Int, Integer, Float, Double, Char, Bool
  , parseByRead	-- :: Read a => String -> TextParser a
    -- ** Combinators specific to string input, lexed haskell-style
  , word	-- :: TextParser String
  , isWord	-- :: String -> TextParser ()
  , optionalParens	-- :: TextParser a -> TextParser a
  , field	-- :: Parse a => String -> TextParser a
    -- ** Re-export all the more general combinators too
  , module Text.ParserCombinators.Poly
  ) where

import Char (isSpace)
import Text.ParserCombinators.Poly

------------------------------------------------------------------------

-- | A synonym for Parser () Char, i.e. string input, no state
type TextParser a = Parser () Char a

-- | The class @Parse@ is a replacement for @Read@, operating over String input.
--   Essentially, it permits better error messages for why something failed to
--   parse.  It is rather important that @parse@ can read back exactly what
--   is generated by the corresponding instance of @show@.
class Parse a where
    parse     :: TextParser a
    parseList :: TextParser [a]	-- only to distinguish [] and ""
    parseList  = bracket (isWord "[") (isWord "]") (return [])
                   `onFail`
                 bracketSep (isWord "[") (isWord ",") (isWord "]") parse
                   `adjustErr` ("Expected a list, but\n"++)

-- | If there already exists a Read instance for a type, then we can make
--   a Parser for it, but with only poor error-reporting.
parseByRead :: Read a => String -> TextParser a
parseByRead name =
    P (\u s-> case reads s of
                []       -> (Left ("no parse, expected a "++name), u, s)
                [(a,s')] -> (Right a, u, s')
                _        -> (Left ("ambiguous parse, expected a "++name), u, s)
      )

-- | One lexical chunk (Haskell-style lexing)
word :: TextParser String
word = P (\u s-> case lex s of
                   []         -> (Left "no input? (impossible)", u, s)
                   [("",s')]  -> (Left "no input?", u, s')
                   ((x,s'):_) -> (Right x, u, s') )

-- | Ensure that the next input word is a given string.  (Note the input
--   is lexed as haskell, so wordbreaks at spaces, symbols, etc)
isWord :: String -> TextParser String
isWord w = do { w' <- word
              ; if w'==w then return w else fail ("expected "++w++" got "++w')
              }

-- | Allow true string parens around an item.
optionalParens :: TextParser a -> TextParser a
optionalParens p = bracket (isWord "(") (isWord ")") p `onFail` p

-- | Deal with named field syntax
field :: Parse a => String -> TextParser a
field name = do { isWord name; isWord "="; parse }

------------------------------------------------------------------------
-- Instances for all the Standard Prelude types.

-- Basic types
instance Parse Int where
    parse = parseByRead "Int"
instance Parse Integer where
    parse = parseByRead "Integer"
instance Parse Float where
    parse = parseByRead "Float"
instance Parse Double where
    parse = parseByRead "Double"
instance Parse Char where
    parse = parseByRead "Char"
 -- parseList = bracket (isWord "\"") (satisfy (=='"'))
 --                     (many (satisfy (/='"')))
	-- not totally correct for strings...
    parseList = do { w <- word; if head w == '"' then return w
                                else fail "not a string" }

instance Parse Bool where
    parse = oneOf [ do { isWord "False"; return False }
                  , do { isWord "True";  return True }
                  ]
            `adjustErr` (++"\n  expected a Bool (True or False)")

instance Parse Ordering where
    parse = oneOf [ do { isWord "LT";  return LT }
                  , do { isWord "EQ";  return EQ }
                  , do { isWord "GT";  return GT }
                  ]
            `adjustErr` (++"\n  expected an Ordering (LT, EQ, or GT)")

-- Structural types
instance Parse () where
    parse = P p
      where p u []       = (Left "no input: expected a ()", u, [])
            p u ('(':cs) = case dropWhile isSpace cs of
                             (')':s) -> (Right (), u, s)
                             _       -> (Left "Expected ) after (", u, cs)
            p u (c:cs) | isSpace c = p u cs
                       | otherwise = ( Left ("Expected a (), got "++show c)
                                     , u, (c:cs))

instance (Parse a, Parse b) => Parse (a,b) where
    parse = do{ isWord "(" `adjustErr` ("Opening a 2-tuple\n"++)
              ; x <- parse `adjustErr` ("1st item of a 2-tuple\n"++)
              ; isWord "," `adjustErr` ("Separating a 2-tuple\n"++)
              ; y <- parse `adjustErr` ("2nd item of a 2-tuple\n"++)
              ; isWord ")" `adjustErr` ("Closing a 2-tuple\n"++)
              ; return (x,y) }

instance (Parse a, Parse b, Parse c) => Parse (a,b,c) where
    parse = do{ isWord "(" `adjustErr` ("Opening a 3-tuple\n"++)
              ; x <- parse `adjustErr` ("1st item of a 3-tuple\n"++)
              ; isWord "," `adjustErr` ("Separating(1) a 3-tuple\n"++)
              ; y <- parse `adjustErr` ("2nd item of a 3-tuple\n"++)
              ; isWord "," `adjustErr` ("Separating(2) a 3-tuple\n"++)
              ; z <- parse `adjustErr` ("3rd item of a 3-tuple\n"++)
              ; isWord ")" `adjustErr` ("Closing a 3-tuple\n"++)
              ; return (x,y,z) }

instance Parse a => Parse (Maybe a) where
    parse = oneOf [ do { isWord "Just";    fmap Just $ optionalParens parse }
                  , do { isWord "Nothing"; return Nothing }
                  ]
            `adjustErr` (++"\n  expected a Maybe (Just or Nothing)")

instance (Parse a, Parse b) => Parse (Either a b) where
    parse = oneOf [ do { isWord "Left";  fmap Left  $ optionalParens parse }
                  , do { isWord "Right"; fmap Right $ optionalParens parse }
                  ]
            `adjustErr` (++"\n  expected an Either (Left or Right)")

instance Parse a => Parse [a] where
    parse = parseList

------------------------------------------------------------------------
